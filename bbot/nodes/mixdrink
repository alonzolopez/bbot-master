#! /usr/bin/env python

import roslib
import rospy
import actionlib
import random
import sys
from bbot import BBOTTrajectoryClient
from bbot import bbotAnalysis
import math
import numpy as np

from control_msgs.msg import (
	FollowJointTrajectoryAction,
	FollowJointTrajectoryGoal,
	JointTolerance,
)
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from geometry_msgs.msg import Pose
from bbot import MixingTaskStateMachine
from scipy.spatial.transform import Rotation as R

grip_open_angle = -0.7
grip_close_angle = 0.1


##### Rotation helper functions ######
def quat_to_dcm(quat):
	# this method turns a quaternion into a direction cosine matrix using the scipy library
	r = R.from_quat(quat)
	return r.as_dcm()

def to_transformation(dcm, translation):
	# this method combines a dcm and translation vector into a 4x4 homogenous transformation matrix
	trans = np.empty((4,4))
	trans[0:3,0:3] = dcm
	trans[3,:] = [0, 0, 0, 1]
	trans[0:3,3] = translation
	return(np.matrix(trans))

def msg_to_transformation(msg):
	# this method uses the helper functions to turn a Pose msg into a 4x4 homogenous transformation matrix
	quat = [msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w]
	dcm = quat_to_dcm(quat)
	pos = [msg.position.x, msg.position.y, msg.position.z]
	return to_transformation(dcm, pos)

##### Translation helper functions #####
def add_z(pose, dz):
	new_pose = np.matrix(np.copy(pose))
	new_pose[2,3] += dz
	return new_pose

def add_x(pose, dx):
	new_pose = np.matrix(np.copy(pose))
	new_pose[0,3] += dx
	return new_pose

##### Gripper helper functions #####
def open_gripper(q):
	# takes in a q vector of joint positions and returns a new q vector with only the gripper joint angle changed
	# changes the gripper joint angle to the open position
	new_q = list(q)
	new_q[6] = grip_open_angle
	return new_q

def close_gripper(q):
	# takes in a q vector of joint positions and returns a new q vector with only the gripper joint angle changed
	# changes the gripper joint angle to the closed position
	new_q = list(q)
	new_q[6] = grip_close_angle
	return new_q

##### aruco callbacks #####
def cup_1_callback(msg, args):
	# this method is called everytime the pose is estimated for cup 1 aruco
	# this method updates the task_space model given the new reading
	transmatrix = msg_to_transformation(msg)
	task_space = args
	task_space.update_cup_1(transmatrix)
	
def cup_2_callback(msg, args):
	# this method is called everytime the pose is estimated for cup 2 aruco
	# this method updates the task_space model given the new reading
	transmatrix = msg_to_transformation(msg)
	task_space = args
	task_space.update_cup_2(transmatrix)

def cup_m_callback(msg, args):
	# this method is called everytime the pose is estimated for mixing cup aruco
	# this method updates the task_space model given the new reading
	transmatrix = msg_to_transformation(msg)
	task_space = args
	task_space.update_cup_m(transmatrix)

def robot_callback(msg, args):
	# this method is called everytime the pose is estimated for bbot's base aruco
	# this method updates the task_space model given the new reading
	transmatrix = msg_to_transformation(msg)
	task_space = args
	task_space.update_base(transmatrix)

def rotate_motor_6(q, dtheta):
	new_q = list(q)
	new_q[5] += dtheta
	return new_q

##### Functions that run trajectories #####
def run_cup_1(btj, task_space, bbot):
	pos = []
	cup1_grip_pose = task_space.TBJ # change for cup 2
	cup_m_dropoff_pose = task_space.TBM
	default_config = [[-1,1,-1,1]]
	dz = cup_m_dropoff_pose[2,3]
	dump_angle = -3*math.pi/4.0

	# add_z(cup1_grip_pose, 1.0)

	# position B
	time_b = 1.0
	q_b = [0.0, 0.0, -math.pi/2.0, 0.0, 0.0, 0.0, grip_open_angle, time_b]
	pos.append(q_b)	
	
	# position C
	time_c = time_b + 2.0
	q_c, __ = bbot.IK(add_z(cup1_grip_pose, dz), default_config)
	q_c = q_c.tolist()[0]
	q_c.extend((grip_open_angle, time_c))
	pos.append(q_c)

	# position D_pre
	time_d_pre = time_c + 1.0
	q_d_pre, __ = bbot.IK(add_x(cup1_grip_pose, -0.05), default_config)
	print("IK result q_d_pre")
	print(q_d_pre)
	q_d_pre = q_d_pre.tolist()[0]
	q_d_pre.extend((grip_open_angle, time_d_pre))
	pos.append(q_d_pre)

	# position D - 
	time_d = time_d_pre + 1.0
	q_d, __ = bbot.IK(cup1_grip_pose, default_config)
	print("IK result q_d")
	print(q_d)
	print(cup1_grip_pose)
	q_d = q_d.tolist()[0]
	q_d.extend((grip_open_angle, time_d))
	pos.append(q_d)

	# position E - grab the cup with grip closed
	time_e = time_d + 1.0
	q_e = close_gripper(q_d)
	q_e[7] = time_e
	pos.append(q_e)

	# position F - raise the cup with grip closed
	time_f = time_e + 2.0
	q_f, __ = bbot.IK(add_z(cup1_grip_pose, dz), default_config)
	print("IK result q_f")
	print(q_f)
	print(add_z(cup1_grip_pose, dz))
	q_f = q_f.tolist()[0]
	q_f.extend((grip_close_angle, time_f))
	pos.append(q_f)
	print(q_f)

	# position H - hover
	time_h = time_f + 3.0
	print(time_h)
	print("\n")
	q_h, __ = bbot.IK(cup_m_dropoff_pose, default_config)
	print("IK result q_h")
	print(q_h)
	q_h = q_h.tolist()[0]
	q_h.extend((grip_close_angle, time_h))
	pos.append(q_h)

	# position I - dump
	time_i = time_h + 0.25
	q_i = rotate_motor_6(q_h, dump_angle)
	q_i[7] = time_i
	pos.append(q_i)
	print(time_h)
	print(time_i)
	print("\n")

	# position J - return to hover
	time_j = time_i + 0.25
	q_j = list(q_h)
	q_j[7] = time_j
	pos.append(q_j)
	print(time_h)
	print(time_i)
	print(time_j)
	print("\n")

	# position K - same as F, just update time arg
	time_k = time_j + 2.0
	q_k = list(q_f)
	q_k[7] = time_k
	pos.append(q_k)

	# position L - same as E, just update time arg
	time_l = time_k + 1.0
	q_l = list(q_e)
	q_l[7] = time_l
	pos.append(q_l)

	# position M - same as D, just update time arg
	time_m = time_l + 0.5
	q_m = list(q_d)
	q_m[7] = time_m
	pos.append(q_m)

	# position M_post - same as D_pre, just update time arg
	time_m_post = time_m + 1.0
	q_m_post = list(q_d_pre)
	q_m_post[7] = time_m_post
	pos.append(q_m_post)

	# position N - same as as C, just update time arg
	time_n = time_m_post + 1.0
	q_n = list(q_c)
	q_n[7] = time_n
	pos.append(q_n)

	# position O - same as B, just update time arg
	time_o = time_n + 2.0
	q_o = list(q_b)
	q_o[7] = time_o
	pos.append(q_o)
	print(pos)




	result = btj.sendPositionTrajectory(pos, 30)
	rospy.loginfo("Completed. error_code: " + str(result))

def run_cup_2(btj, task_space, bbot):
	pos2 = []
	cup2_grip_pose = task_space.TBK # change for cup 2
	cup_m_dropoff_pose = task_space.TBM
	default_config = [[-1,1,-1,1]]
	dz = cup_m_dropoff_pose[2,3]
	dump_angle = -3*math.pi/4.0

	# add_z(cup2_grip_pose, 1.0)

	# position B
	time_b = 1.0
	q_b = [0.0, 0.0, -math.pi/2.0, 0.0, 0.0, 0.0, grip_open_angle, time_b]
	pos2.append(q_b)	
	
	# position C
	time_c = time_b + 2.0
	q_c, __ = bbot.IK(add_z(cup2_grip_pose, dz), default_config)
	q_c = q_c.tolist()[0]
	q_c.extend((grip_open_angle, time_c))
	pos2.append(q_c)

	# position D_pre
	time_d_pre = time_c + 1.0
	q_d_pre, __ = bbot.IK(add_x(cup2_grip_pose, -0.05), default_config)
	print("IK result q_d_pre")
	print(q_d_pre)
	q_d_pre = q_d_pre.tolist()[0]
	q_d_pre.extend((grip_open_angle, time_d_pre))
	pos2.append(q_d_pre)

	# position D - 
	time_d = time_d_pre + 1.0
	q_d, __ = bbot.IK(cup2_grip_pose, default_config)
	print("IK result q_d")
	print(q_d)
	print(cup2_grip_pose)
	q_d = q_d.tolist()[0]
	q_d.extend((grip_open_angle, time_d))
	pos2.append(q_d)

	# position E - grab the cup with grip closed
	time_e = time_d + 1.0
	q_e = close_gripper(q_d)
	q_e[7] = time_e
	pos2.append(q_e)

	# position F - raise the cup with grip closed
	time_f = time_e + 2.0
	q_f, __ = bbot.IK(add_z(cup2_grip_pose, dz), default_config)
	print("IK result q_f")
	print(q_f)
	print(add_z(cup2_grip_pose, dz))
	q_f = q_f.tolist()[0]
	q_f.extend((grip_close_angle, time_f))
	pos2.append(q_f)
	print(q_f)

	# position H - hover
	time_h = time_f + 3.0
	print(time_h)
	print("\n")
	q_h, __ = bbot.IK(cup_m_dropoff_pose, default_config)
	print("IK result q_h")
	print(q_h)
	q_h = q_h.tolist()[0]
	q_h.extend((grip_close_angle, time_h))
	pos2.append(q_h)

	# position I - dump
	time_i = time_h + 0.25
	q_i = rotate_motor_6(q_h, dump_angle)
	q_i[7] = time_i
	pos2.append(q_i)
	print(time_h)
	print(time_i)
	print("\n")

	# position J - return to hover
	time_j = time_i + 0.25
	q_j = list(q_h)
	q_j[7] = time_j
	pos2.append(q_j)
	print(time_h)
	print(time_i)
	print(time_j)
	print("\n")

	# position K - same as F, just update time arg
	time_k = time_j + 2.0
	q_k = list(q_f)
	q_k[7] = time_k
	pos2.append(q_k)

	# position L - same as E, just update time arg
	time_l = time_k + 1.0
	q_l = list(q_e)
	q_l[7] = time_l
	pos2.append(q_l)

	# position M - same as D, just update time arg
	time_m = time_l + 0.5
	q_m = list(q_d)
	q_m[7] = time_m
	pos2.append(q_m)

	# position M_post - same as D_pre, just update time arg
	time_m_post = time_m + 1.0
	q_m_post = list(q_d_pre)
	q_m_post[7] = time_m_post
	pos2.append(q_m_post)

	# position N - same as as C, just update time arg
	time_n = time_m_post + 1.0
	q_n = list(q_c)
	q_n[7] = time_n
	pos2.append(q_n)

	# position O - same as B, just update time arg
	time_o = time_n + 2.0
	q_o = list(q_b)
	q_o[7] = time_o
	pos2.append(q_o)
	print(pos2)




	result = btj.sendPositionTrajectory(pos2, 30)
	rospy.loginfo("Completed. error_code: " + str(result))



if __name__ == '__main__':
	try:
		rospy.init_node('demo_node')
		btj = BBOTTrajectoryClient()
		bbot = bbotAnalysis()
		task_space = MixingTaskStateMachine()

		
		# subscribe to all the pose nodes to record where the cups and robot are relative to each other
		rospy.Subscriber('aruco_1/aruco_double_j/pose', Pose, cup_1_callback, (task_space)) # sub to cup 1 pose (marker id 99)
		rospy.Subscriber('aruco_1/aruco_double_j/pose2', Pose, cup_2_callback, (task_space)) # sub to cup 2 pose (marker id 05)
		rospy.Subscriber('aruco_2/aruco_double_b/pose', Pose, cup_m_callback, (task_space)) # sub to mixing cup pose (marker id 44)
		rospy.Subscriber('aruco_2/aruco_double_b/pose2', Pose, robot_callback, (task_space)) # sub to robot base pose (marker id 26)
		rospy.sleep(5) # sleep for 1 sec while the aruco poses come in

		# grab the first cup, dump it, and return it
		# run_cup_1(btj, task_space, bbot)

		# grab the second cup, dump it, and return it
		run_cup_2(btj, task_space, bbot)


	except rospy.ROSInterruptException:
		rospy.loginfo("program interrupted before completion")
